# TDD

Test-driven Development

테스트 → 구현

테스트 코드 먼저 작성 후 테스트를 통과시키기 위해 개발 진행

### AS-IS

- 만들 기능에 어떤 클래스와 인터페이스를 도출할지 결정
- 어떤 메서드를 만들지 결정
- 어떻게 구현할지 결정
- 기능 구현 완료 후 기능 테스트
- 문제 발생시 디버깅
    - 코드가 많을 경우 디버깅 시간이 길어진다.
    - 클래스 파일 변경 시 톰캣서버 재시작하는 등.. 노가다

### TO-BE

- 테스트를 먼저 작성하고, 테스트를 통과시키기 위한 코드를 추가하는 과정을 반복하면서 점진적으로 기능을 완성해 나간다.
- 테스트 코드 작성시 고려할 사항
    - 메서드 이름
    - 파라미터는 몇개? 타입? 반환 값?
    - 정적메서드? 인스턴스 메서드?
    - 메서드 클래스 이름?

*AssertionFailedError

- Assertion
    - 개발자가 참이라고 가정하는 상태를 명시하기 위해서 사용된다. 에를 들어, 어떤 메소드가 파라미터로 양수만 입력받아야 한다고 확신한다면, Assertion을 사용하여 그 사실을(즉, 파라미터가 양수라는 것을) 명시할 수 있다.
    - 예외는 프로그램을 수행하는 도중에 발생하는 비정상적인 상태를 처리하기는 하지만 프로그램의 코드가 수행되는 도중에 예외가 발생한다. 반면에 Assertion은 프로그램이 올바르게 수행될 수 있는 조건을 명시해주어 그 조건을 만족시키는 경우에만 코드가 실행될 수 있도록 해 준다.
    - 따라서 Assertion은 프로그램이 올바르게 실행되도록 해주는 효과적인 도구가 될 수 있으며, 프로그램의 안정성을 높여줄 수 있다.
- 정적 메서드와 인스턴스 메서드
    - 인스턴스 변수 사용유무
    - 정적 메서드 : `Calculator.plus();`
    - 인스턴스 메서드 : `Calculator cal = new Calculator();`

### TDD 흐름

<aside>
💡 테스트 → 코딩 → 리팩토링

</aside>

레드🔴 - 그린🟢 - 리팩터 라고 부르기도 함.

1. 기능을 검증하는 테스트를 먼저 작성한다.
2. 테스트를 통과하지 못한다면🔴 테스트를 통과시키기 위한 코드를 추가한다.
3. 테스트 통과🟢 후 리팩토링한다.

이러한 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것이다.

### 테스트가 개발을 주도

<aside>
💡 테스트 코드를 먼저 작성하면 테스트가 개발을 주도하게 된다.

</aside>

- 테스트를 작성하는 과정에서 구현을 생각하지 않고, 해당 기능이 올바르게 작동하는지 검증할 수 있는 테스트 코드를 만들었을 뿐이다.
- 테스트 코드를 만들면 다음 개발 범위가 정해진다.
- 테스트 코드가 추가되면서 검증하는 범위가 넓어질 수록 구현도 점점 완성되어간다.

### 지속적인 코드 정리

- 당장 리팩토링을 하지 않더라도 테스트 코드가 있으면 리팩토링을 보다 과감하게 진행할 수 있다.
- 기존에는 코드 수정을 꺼리게 되나, 해당 기능이 온전하게 동작한다는 것을 검증해 주는 테스트가 있다면 코드 수정에 대한 심리적 불안감을 줄여준다.
- 따라서 지속적으로 코드정리를 하게 되고, 코드 품질이 급격히 나빠지지 않게 막아준다.
- 향후 유지보수 비용을 낮출 수 있다.

### 빠른 피드백

- 코드 수정에 대한 피드백이 빠르다.
- 새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인 할 수 있다. → 잘못된 코드가 배포되는 것을 방지한다.

### 구현하기 쉬운 테스트부터 시작하기

- 빠르게 테스트 통과시킬 수 있음
- 암호 강도 측정의 경우
  - 모든 조건을 충족하는 경우 → STRONG 리턴
  - 모든 조건을 충족하지 않는 경우 → WEAK 리턴
    - 모든 규칙을 충족하지 않는 경우
    - 한 규칙만 충족
    - 두 규칙 충족

### 예외상황을 먼저 테스트

- 초반에 예외상황을 테스트
- 암호 등급 측정 예의 경우 암호값이 없는 상황에 대한 테스트

### 완급 조절

- 한번에 얼마만큼의 코드를 작성할 것인가
- 아래 과정을 따르도록 한다.
  - 정해진 값을 리턴
  - 값 비교를 이용해서 정해진 값을 리턴
  - 다양한 테스트를 추가하면서 구현을 일반화

### 지속적인 리팩토링

- 작은 리팩토링 대상은 바로 실행
- 메서드 추출 등 메서드의 구조에 영향을 주는 리팩토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행

## 테스트 작성 순서 연습

### 쉬운것 부터 테스트

- 만료일 계산기의 경우: 한달 뒤 같은 날을 만료일로 계산 이 제일 쉬움

### 예를 추가하면서 구현을 일반화

- 동일 조건의 예를 추가하면서 구현을 일반화 → 테스트 코드 수정

### 코드 정리: 중복 제거

- 무조건적인 중복 제거는 테스트코드의 가독성을 떨어뜨릴수도 있음

### 예외상황 처리

- 월별로 일자가 다름

### 테스트할 목록 정리

- 테스트할 목록을 미리 정리하면 좋다.
  - 1만원 납부하면 한달 뒤가 만료일
  - 달의 마지막 날에 납부하면 다음달 마지막 날이 만료일
  - 2만원 납부하면 2개월 뒤가 만료일
  - 3만원 납부하면 3개월 뒤가 만료일
  - 10만원 납부하면 1년 뒤가 만료일
- 어떤 테스트가 구현이 쉬울지 또는 어떤 테스트가 예외적인지 상상한다.
- 새로운 테스트 사례를 발견하면 그 사례를 목록에 추가한다.
- 테스트-통과-리팩토링 하는 과정을 짧은 리듬으로 반복한다.

### 시작이 안될때는 단언부터 고민

- 검증하는 코드부터 작성하기 시작한다.
- 만료일 계산 기능: 만료일을 검증하는 코드부터 작성해 본다.

### 구현이 막히면

- 구현이 막힐 때는 과감하게 코드를 지우고 처음부터 시작
- 순서를 바꾸어서 다시 진행
- 쉬운테스트, 예외적인 테스트, 완급 조절을 상기하면서 진행

### 기능 명세 구체화
- 개발자가 요구사항 명세를 전달받으면 기능의 입력과 결과를 도출해야 한다. 기능의 입력과 결과는 명확해야 한다.
- 다양한 테스트 사례를 추가하는 과정에서 구현하기 애매한 점을 발견하면 기획자와 논의해서 상황에 따라 기능이 어떻게 동작해야 하는지 구체적으로 정리해야 한다.

---

## JUnit5 기초

### JUnit5 모듈 구성

- JUnit 플랫폼: 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API를 제공
- JUnit 주피터: JUnit5를 위한 테스트 API와 실행 엔진을 제공
- JUnit 빈티지: JUnit3 과 4로 작성된 테스트를 JUnit5 플랫폼에서 실행하기 위한 모듈을 제공

## 테스트 라이프사이클

### `@BeforeEach` 어노테이션과 `@AfterEach` 어노테이션

1. 테스트 메서드를 포함한 객체 생성
2. (존재하면) `@BeforeEach` 어노테이션 붙은 메서드 실행
3. `@Test` 어노테이션 붙은 메서드 실행
4. (존재하면) `@AfterEach` 어노테이션 붙은 메서드 실행

### `@BeforeAll` 어노테이션과 `@AfterAll` 어노테이션

- `@BeforeAll`: 한 클래스의 모든 테스트 메서드가 실행되기 전에 특정 작업을 수행해야 할 때 사용
- `@AfterAll`: 클래스의 모든 테스트 메서드를 실행한 뒤에 실행
- 두 어노테이션 모두 정적 메서드에 적용

### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기

- 각 테스트 메서드는 서로 독립적으로 동작해야 한다.
- 테스트 메서드가 서로 필드를 공유하거나, 실행 순서를 가정하고 테스트를 작성하지 말아야 한다.

### 추가 어노테이션: `@DisplayName`, `@Disabled`

- `@DisplayName`: 테스트에 표시 이름 붙이는 기능
- `@Disabled`: 특정 테스트를 실행하지 않고 싶을때. ex. 테스트 코드 미완성, 잠시 테스트 실행 하지 않아야 할때 등등

### 모든 테스트 실행하기

- 운영 환경에 배포하기 전에는 모든 테스트를 실행해서 깨지는 테스트가 없는지 확인한다.
- 명령어 사용
  - `mvn test` (래퍼 사용시 `mvnw test`)
  - `gradle test` (래퍼 사용시 `gradlew test`)
  
---
